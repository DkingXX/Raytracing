#ifndef __FLYSCENE__
#define __FLYSCENE__

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <tucano/effects/phongmaterialshader.hpp>
#include <tucano/mesh.hpp>
#include <tucano/shapes/camerarep.hpp>
#include <tucano/shapes/cylinder.hpp>
#include <tucano/shapes/sphere.hpp>
#include <tucano/shapes/box.hpp>
#include <tucano/utils/flycamera.hpp>
#include <tucano/utils/imageIO.hpp>
#include <tucano/utils/mtlIO.hpp>
#include <tucano/utils/objimporter.hpp>
#include "SphereLight.hpp"
#include "box.hpp"
#include "PointLight.hpp"
#include "AccelerationStructure.hpp"

#define MAX_RECURSIVE_DEPTH 2
#define MAX_FACES_PER_BOX 50
#define MAX_OVERLAP 0.2
#define SUPERSAMPLING
//#define MULTITHREADING 
#define ACCEL_STRUCTURE

class Flyscene {

public:
  Flyscene(void) {}
  
  /**
   * @brief Initializes the shader effect
   * @param width Window width in pixels
   * @param height Window height in pixels
   */
  void initialize(int width, int height);

  /**
   * Repaints screen buffer.
   **/
  virtual void paintGL();

  /**
   * Perform a single simulation step.
   **/
  virtual void simulate(GLFWwindow *window);

  /**
   * Returns the pointer to the flycamera instance
   * @return pointer to flycamera
   **/
  Tucano::Flycamera *getCamera(void) { return &flycamera; }

  /**
  * @brief Change the background color of the scene
  */
  void changeBackground(void);

  /**
   * @brief Add a new light source at the position of the camera and color white
   */
  void addLight(void);

  /**
  * @brief Remove all the lights from the scene
  */
  void clearLights();

  /**
  * @brief Turn the bounding boxes on/off in the 3D display
  */
  void toggleBoundingBoxes() { displayBoundingBoxes = !displayBoundingBoxes; }

  /**
   * @brief Create a debug ray at the current camera location and passing
   * through pixel that mouse is over
   * @param mouse_pos Mouse cursor position in pixels
   */
  void createDebugRay(const Eigen::Vector2f& mouse_pos);

  /**
  * @brief Highlight nth reflection of the debug ray
  */
  void highlightRay();

  /**
   * @brief Raytrace your scene from current camera position  
   */
  void raytraceScene(int width = 0, int height = 0);

  /**
   * @brief Trace a single ray from the camera passing through dest
   * @param origin Ray origin
   * @param dest Other point on the ray, usually screen coordinates
   * @return a RGB color
   */
  Eigen::Vector3f traceRay(Eigen::Vector3f& origin, Eigen::Vector3f& dest, const int& depth, bool isDebug);


private:
  // A simple phong shader for rendering meshes
  Tucano::Effects::PhongMaterial phong;

  // A fly through camera
  Tucano::Flycamera flycamera;

  // The size of the image generated by ray tracing
  Eigen::Vector2i raytracing_image_size;

  // A camera representation for animating path (false means that we do not
  // render front face)
  Tucano::Shapes::CameraRep camerarep = Tucano::Shapes::CameraRep(false);

  // Scene light represented as a camera
  Tucano::Camera scene_light;

  // List containing all lights for raytracing
  // The phong shading for the 3D view only considers the last light
  vector<SphereLight> lights;

  // List containing all samplingPoints that will be used for calculating the soft shadows
  vector<SphereLight> samplingPoints;

  // Scene meshes
  Tucano::Mesh mesh;

  /// MTL materials
  vector<Tucano::Material::Mtl> materials;
  
  // List containing all (cylinders representing) debug rays
  vector<Tucano::Shapes::Cylinder> debugRays;

  // List containing all (cylinders representing) normal rays
  vector<Tucano::Shapes::Cylinder> normalRays;

  // List containing all (cylinder representing) debug rays to the light
  vector<Tucano::Shapes::Cylinder> lightDebugRays;

  // Structure used to accelerate ray tracing
  AccelerationStructure as;

  // Default background color of the scene
  Eigen::Vector3f backgroundColor = Eigen::Vector3f(0.7, 0.7, 0.7);

  // Indicates whether the bounding boxes will be displayed in the 3D scene
  bool displayBoundingBoxes = true;

  // nth reflected debug ray is highlighted, -1 means no ray is highlighted
  float n = -1;

  // original color of highlighted ray
  Eigen::Vector4f lastColor;

  Eigen::Vector3f calculateShading(Tucano::Face face, Eigen::Vector3f point, Eigen::Vector3f rayDirection, int depth, bool isDebug);

  Eigen::Vector3f calculateDirectLight(Tucano::Face face, Eigen::Vector3f point, Eigen::Vector3f rayDirection, bool isDebug);

  Eigen::Vector3f calculateReflectedLight(Tucano::Face face, Eigen::Vector3f point, Eigen::Vector3f rayDirection, int depth, bool isDebug);

  bool inShadow(Eigen::Vector3f intersectionPoint, Eigen::Vector3f normal, Eigen::Vector3f lightRayDirection, float pointLightDistance);

  bool intersectPlane(Tucano::Face face, Eigen::Vector3f rayDirection, Eigen::Vector3f origin, Eigen::Vector3f& v0, float& D, float& t);

  bool intersectTriangleNearest(Tucano::Face triangle, Eigen::Vector3f rayDirection, Eigen::Vector3f origin, Eigen::Vector3f& point, float maxDistance, float& D);

  bool intersectTriangle(Tucano::Face triangle, Eigen::Vector3f rayDirection, Eigen::Vector3f origin);

  bool pointInTriangle(Eigen::Vector3f v0, Eigen::Vector3f v1, Eigen::Vector3f v2, Eigen::Vector3f p);

  bool intersectBox(Box box, Eigen::Vector3f rayDirection, Eigen::Vector3f origin);

  Eigen::Vector3f reflect(Eigen::Vector3f A, Eigen::Vector3f B);

  Eigen::Vector3f componentWiseMultiplication(Eigen::Vector3f A, Eigen::Vector3f B);

  vector<vector<Eigen::Vector3f>> superSampling(vector<vector<Eigen::Vector3f>> pixel_data);

  void addDebugRay(Eigen::Vector3f origin, Eigen::Vector3f destination, Eigen::Vector3f direction, Eigen::Vector4f color, bool toLight = false);

  Eigen::Vector3f askRGB(float& red, float& green, float& blue);
};

#endif // FLYSCENE
